--- src/superlu_dist_internal_complex.cpp.orig	2020-02-25 16:12:53.779494396 +0000
+++ src/superlu_dist_internal_complex.cpp	2020-02-25 16:13:22.075702493 +0000
@@ -1,6 +1,6 @@
 /*
    Copyright (c) 2012 The Regents of the University of California,
-   through Lawrence Berkeley National Laboratory.  
+   through Lawrence Berkeley National Laboratory.
 
 Author: Lin Lin and Mathias Jacquelin
 
@@ -51,22 +51,22 @@ such enhancements or derivative works th
 #include <superlu_zdefs.h>
 
 #include <numeric>
-#include <Cnames.h>
+#include <superlu_FCnames.h>
 extern "C"{ void
 #ifdef SUPERLU_DIST_MAJOR_VERSION
 #if SUPERLU_DIST_MAJOR_VERSION < 5
-pzsymbfact(superlu_options_t *options, SuperMatrix *A, 
+pzsymbfact(superlu_options_t *options, SuperMatrix *A,
     ScalePermstruct_t *ScalePermstruct, gridinfo_t *grid,
     LUstruct_t *LUstruct, SuperLUStat_t *stat, int *numProcSymbFact,
     int *info, double *totalMemory, double *maxMemory );
 #else
-pzsymbfact(superlu_dist_options_t *options, SuperMatrix *A, 
+pzsymbfact(superlu_dist_options_t *options, SuperMatrix *A,
     ScalePermstruct_t *ScalePermstruct, gridinfo_t *grid,
     LUstruct_t *LUstruct, SuperLUStat_t *stat, int *numProcSymbFact,
     int *info, double *totalMemory, double *maxMemory );
 #endif
 #else
-pzsymbfact(superlu_dist_options_t *options, SuperMatrix *A, 
+pzsymbfact(superlu_dist_options_t *options, SuperMatrix *A,
     ScalePermstruct_t *ScalePermstruct, gridinfo_t *grid,
     LUstruct_t *LUstruct, SuperLUStat_t *stat, int *numProcSymbFact,
     int *info, double *totalMemory, double *maxMemory );
@@ -154,33 +154,33 @@ namespace PEXSI{
 class ComplexSuperLUData_internal{
   friend class ComplexSuperLUData;
 protected:
-  /// @brief SuperLU matrix. 
-  SuperMatrix         A;                        
+  /// @brief SuperLU matrix.
+  SuperMatrix         A;
 
-  /// @brief SuperLU options. 
+  /// @brief SuperLU options.
   ///
   /// Note
   /// ----
   ///
-  /// It is important to have 
+  /// It is important to have
   ///
   /// options.RowPerm           = NOROWPERM;
-  /// 
+  ///
   /// to make sure that symmetric permutation is used.
   ///
 #ifdef SUPERLU_DIST_MAJOR_VERSION
 #if SUPERLU_DIST_MAJOR_VERSION < 5
-  superlu_options_t   options;                  
+  superlu_options_t   options;
 #else
-  superlu_dist_options_t   options;                  
+  superlu_dist_options_t   options;
 #endif
 #else
-  superlu_dist_options_t   options;                  
+  superlu_dist_options_t   options;
 #endif
 
   /// @brief Saves the permutation vectors.  Only perm_c (permutation of
   /// column as well as rows due to the symmetric permutation) will be used.
-  ScalePermstruct_t   ScalePermstruct;          
+  ScalePermstruct_t   ScalePermstruct;
 
   /// @brief SuperLU grid structure.
   gridinfo_t*         grid;
@@ -233,7 +233,7 @@ ComplexSuperLUData_internal::ComplexSupe
   options.Fact              = DOFACT;
   if(opt.RowPerm == "LargeDiag"){
 #ifdef SUPERLU_DIST_MAJOR_VERSION
-#  if SUPERLU_DIST_MAJOR_VERSION < 6 
+#  if SUPERLU_DIST_MAJOR_VERSION < 6
     options.RowPerm         = LargeDiag;
 #  else
     options.RowPerm         = LargeDiag_MC64;
@@ -249,10 +249,10 @@ ComplexSuperLUData_internal::ComplexSupe
   options.IterRefine        = NOREFINE;
   options.ParSymbFact       = NO;
   if(opt.Equil == "YES"){
-    options.Equil             = YES; 
+    options.Equil             = YES;
   }
   else{
-    options.Equil             = NO; 
+    options.Equil             = NO;
   }
 
   options.ReplaceTinyPivot  = YES;
@@ -270,12 +270,12 @@ ComplexSuperLUData_internal::ComplexSupe
 
   if(opt.Symmetric == 1){
     options.RowPerm         = NOROWPERM;
-    options.Equil             = NO; 
+    options.Equil             = NO;
   }
 
   if ( opt.ColPerm == "NATURAL" ){
     options.ColPerm = NATURAL;
-  } 
+  }
   else if( opt.ColPerm == "MMD_AT_PLUS_A" ){
     options.ColPerm = MMD_AT_PLUS_A;
   }
@@ -300,7 +300,7 @@ ComplexSuperLUData_internal::ComplexSupe
 ComplexSuperLUData_internal::~ComplexSuperLUData_internal(){
   if( isLUstructAllocated ){
     Destroy_LU(A.ncol, grid, &LUstruct);
-    LUstructFree(&LUstruct); 
+    LUstructFree(&LUstruct);
   }
   if( isScalePermstructAllocated ){
     ScalePermstructFree(&ScalePermstruct);
@@ -351,7 +351,7 @@ void ComplexSuperLUData_internal::Destro
   isSuperMatrixAllocated = false;
 
   return ;
-} 		// -----  end of method ComplexSuperLUData_internal::DestroyAOnly  ----- 
+} 		// -----  end of method ComplexSuperLUData_internal::DestroyAOnly  -----
 
 
 
@@ -412,16 +412,16 @@ ComplexSuperLUData & ComplexSuperLUData:
 
 
 
-Int ComplexSuperLUData::m (  ) const	
+Int ComplexSuperLUData::m (  ) const
 {
   return ptrData->A.nrow;
-} 		// -----  end of method ComplexSuperLUData::m  ----- 
+} 		// -----  end of method ComplexSuperLUData::m  -----
 
 
-Int ComplexSuperLUData::n (  ) const	
+Int ComplexSuperLUData::n (  ) const
 {
   return ptrData->A.ncol;
-} 		// -----  end of method ComplexSuperLUData::n  ----- 
+} 		// -----  end of method ComplexSuperLUData::n  -----
 
 
 
@@ -447,7 +447,7 @@ void ComplexSuperLUData::DistSparseMatri
     numRowLocal = sparseA.colptrLocal.m() - 1;
     nnzLocal = sparseA.nnzLocal;
 
-    colindLocal = (int_t*)intMalloc_dist(sparseA.nnzLocal); 
+    colindLocal = (int_t*)intMalloc_dist(sparseA.nnzLocal);
     nzvalLocal  = (doublecomplex*)doublecomplexMalloc_dist(sparseA.nnzLocal);
     rowptrLocal = (int_t*)intMalloc_dist(numRowLocal+1);
 
@@ -462,7 +462,7 @@ void ComplexSuperLUData::DistSparseMatri
     numRowLocal = sparseA.colptrLocal.m() - 1;
     nnzLocal = sparseA.nnzLocal;
 
-    colindLocal = (int_t*)intMalloc_dist(sparseA.nnzLocal); 
+    colindLocal = (int_t*)intMalloc_dist(sparseA.nnzLocal);
     nzvalLocal  = (doublecomplex*)doublecomplexMalloc_dist(sparseA.nnzLocal);
     rowptrLocal = (int_t*)intMalloc_dist(numRowLocal+1);
 
@@ -482,7 +482,7 @@ void ComplexSuperLUData::DistSparseMatri
     numRowLocal = sparseB.colptrLocal.m() - 1;
     nnzLocal = sparseB.nnzLocal;
 
-    colindLocal = (int_t*)intMalloc_dist(sparseB.nnzLocal); 
+    colindLocal = (int_t*)intMalloc_dist(sparseB.nnzLocal);
     nzvalLocal  = (doublecomplex*)doublecomplexMalloc_dist(sparseB.nnzLocal);
     rowptrLocal = (int_t*)intMalloc_dist(numRowLocal+1);
 
@@ -505,7 +505,7 @@ void ComplexSuperLUData::DistSparseMatri
   }
 
   // Construct the distributed matrix according to the SuperLU_DIST format
-  zCreate_CompRowLoc_Matrix_dist(&ptrData->A, sparseA.size, sparseA.size, nnzLocal, 
+  zCreate_CompRowLoc_Matrix_dist(&ptrData->A, sparseA.size, sparseA.size, nnzLocal,
       numRowLocal, firstRow,
       nzvalLocal, colindLocal, rowptrLocal,
       SLU_NR_loc, SLU_Z, SLU_GE);
@@ -515,7 +515,7 @@ void ComplexSuperLUData::DistSparseMatri
 
   return;
 
-} 		// -----  end of method ComplexSuperLUData::DistSparseMatrixToSuperMatrixNRloc ----- 
+} 		// -----  end of method ComplexSuperLUData::DistSparseMatrixToSuperMatrixNRloc -----
 
 
 void
@@ -523,7 +523,7 @@ ComplexSuperLUData::DestroyAOnly	(  )
 {
   ptrData->DestroyAOnly();
   return ;
-} 		// -----  end of method ComplexSuperLUData::DestroyAOnly  ----- 
+} 		// -----  end of method ComplexSuperLUData::DestroyAOnly  -----
 
 void
 ComplexSuperLUData::SymbolicFactorize	(  )
@@ -552,7 +552,7 @@ ComplexSuperLUData::SymbolicFactorize	(
 
   double totalMemory = 0.0, maxMemory = 0.0;
 
-  pzsymbfact(&ptrData->options, &A, &ptrData->ScalePermstruct, ptrData->grid, 
+  pzsymbfact(&ptrData->options, &A, &ptrData->ScalePermstruct, ptrData->grid,
       &ptrData->LUstruct, &ptrData->stat, &ptrData->numProcSymbFact, &ptrData->info,
       &totalMemory, &maxMemory);
   PStatFree(&ptrData->stat);
@@ -563,7 +563,7 @@ ComplexSuperLUData::SymbolicFactorize	(
 
 #if ( _DEBUGlevel_ >= 0 )
   statusOFS << "Memory cost of symbolic factorization (MB): " << std::endl;
-  statusOFS << "Total: " << totalMemory << ", Average: " << 
+  statusOFS << "Total: " << totalMemory << ", Average: " <<
     totalMemory / ( ptrData->grid->nprow * ptrData->grid->npcol )
     << ", Max: " << maxMemory << std::endl << std::endl;
 #endif
@@ -571,11 +571,11 @@ ComplexSuperLUData::SymbolicFactorize	(
 
 
   ptrData->isScalePermstructAllocated = true;
-  ptrData->isLUstructAllocated        = true; 
+  ptrData->isLUstructAllocated        = true;
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::SymbolicFactorize  ----- 
+} 		// -----  end of method ComplexSuperLUData::SymbolicFactorize  -----
 
 
 void
@@ -583,13 +583,13 @@ ComplexSuperLUData::Distribute	(  )
 {
   if( ptrData->isScalePermstructAllocated == false ){
     ErrorHandling( "ScalePermstruct has not been allocated by SymbolicFactorize." );
-  }	
+  }
   if( ptrData->isLUstructAllocated == false ){
     ErrorHandling( "LUstruct has not been allocated by SymbolicFactorize." );
-  }	
+  }
   if( ptrData->isSuperMatrixAllocated == false ){
     ErrorHandling( "SuperMatrix has not been allocated." );
-  }	
+  }
 
   Int* perm_c = ptrData->ScalePermstruct.perm_c;
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
@@ -598,15 +598,15 @@ ComplexSuperLUData::Distribute	(  )
   // Apply column permutation to the original distributed A
   for(Int j = 0; j < nnzLocal; j++)
     colind[j] = perm_c[colind[j]];
-  // Distribute Pc*Pr*diag(R)*A*diag(C)*Pc' into L and U storage.  
+  // Distribute Pc*Pr*diag(R)*A*diag(C)*Pc' into L and U storage.
   // NOTE: the row permutation Pc*Pr is applied internally in the
-  // distribution routine. 
-  float dist_mem_use = pzdistribute(SamePattern_SameRowPerm, ptrData->A.nrow, 
+  // distribution routine.
+  float dist_mem_use = pzdistribute(SamePattern_SameRowPerm, ptrData->A.nrow,
       &ptrData->A, &ptrData->ScalePermstruct, NULL, &ptrData->LUstruct, ptrData->grid);
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::Distribute  ----- 
+} 		// -----  end of method ComplexSuperLUData::Distribute  -----
 
 
 void
@@ -620,21 +620,21 @@ ComplexSuperLUData::NumericalFactorize	(
   double anorm = pzlangs( norm, &ptrData->A, ptrData->grid );
 
   PStatInit(&ptrData->stat);
-  pzgstrf(&ptrData->options, ptrData->A.nrow, ptrData->A.ncol, 
-      anorm, &ptrData->LUstruct, ptrData->grid, &ptrData->stat, &ptrData->info); 
+  pzgstrf(&ptrData->options, ptrData->A.nrow, ptrData->A.ncol,
+      anorm, &ptrData->LUstruct, ptrData->grid, &ptrData->stat, &ptrData->info);
 
 #ifdef _PRINT_STATS_
-  statusOFS<<"******************SUPERLU STATISTICS****************"<<std::endl;  
-  statusOFS<<"Number of tiny pivots: "<<ptrData->stat.TinyPivots<<std::endl;  
-  statusOFS<<"Number of look aheads: "<<ptrData->stat.num_look_aheads<<std::endl;  
-  
+  statusOFS<<"******************SUPERLU STATISTICS****************"<<std::endl;
+  statusOFS<<"Number of tiny pivots: "<<ptrData->stat.TinyPivots<<std::endl;
+  statusOFS<<"Number of look aheads: "<<ptrData->stat.num_look_aheads<<std::endl;
+
   float flopcnt = 0;
   MPI_Allreduce(&ptrData->stat.ops[FACT], &flopcnt, 1, MPI_FLOAT, MPI_SUM, ptrData->grid->comm);
-  statusOFS<<"Number of FLOPS for factorization: "<<flopcnt<<std::endl;  
+  statusOFS<<"Number of FLOPS for factorization: "<<flopcnt<<std::endl;
   if(!ptrData->grid->iam){
     std::cout<<"Total FLOPs for factorization is "<<flopcnt<<std::endl;
   }
-  statusOFS<<"****************************************************"<<std::endl;  
+  statusOFS<<"****************************************************"<<std::endl;
 #endif
 
   PStatFree(&ptrData->stat);
@@ -651,7 +651,7 @@ ComplexSuperLUData::NumericalFactorize	(
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::NumericalFactorize  ----- 
+} 		// -----  end of method ComplexSuperLUData::NumericalFactorize  -----
 
 
 void
@@ -667,14 +667,14 @@ ComplexSuperLUData::ConvertNRlocToNC	( C
 
   // TODO real arithmetic
   const Int NEED_VALUE = 1;
-  pzCompRow_loc_to_CompCol_global(NEED_VALUE, &ptrData->A, ptrData->grid, 
+  pzCompRow_loc_to_CompCol_global(NEED_VALUE, &ptrData->A, ptrData->grid,
       &aptrData->ptrData->A);
 
   ptrData->isSuperMatrixAllocated = true;
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::ConvertNRlocToNC  ----- 
+} 		// -----  end of method ComplexSuperLUData::ConvertNRlocToNC  -----
 
 void
 ComplexSuperLUData::MultiplyGlobalMultiVector	( NumMat<Complex>& xGlobal, NumMat<Complex>& bGlobal )
@@ -690,12 +690,12 @@ ComplexSuperLUData::MultiplyGlobalMultiV
       << "The matrix is of type " << ptrData->A.Stype << std::endl
       << "Consider using ConvertNRlocToNC subroutine" << std::endl;
     ErrorHandling( msg.str().c_str() );
-  }	
-  zFillRHS_dist(trans, nrhs, (doublecomplex*)xGlobal.Data(), m, 
+  }
+  zFillRHS_dist(trans, nrhs, (doublecomplex*)xGlobal.Data(), m,
       &ptrData->A, (doublecomplex*) bGlobal.Data(), m);
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::MultiplyGlobalMultiVector  ----- 
+} 		// -----  end of method ComplexSuperLUData::MultiplyGlobalMultiVector  -----
 
 
 void
@@ -707,7 +707,7 @@ ComplexSuperLUData::DistributeGlobalMult
     msg << "DistributeGlobalMultiVector requires SLU_NR_loc matrix with type " << SLU_NR_loc << std::endl
       << "The matrix is of type " << ptrData->A.Stype << std::endl;
     ErrorHandling( msg.str().c_str() );
-  }	
+  }
 
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
 
@@ -724,7 +724,7 @@ ComplexSuperLUData::DistributeGlobalMult
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::DistributeGlobalMultiVector  ----- 
+} 		// -----  end of method ComplexSuperLUData::DistributeGlobalMultiVector  -----
 
 
 void ComplexSuperLUData::GatherDistributedMultiVector	( NumMat<Complex>& xGlobal, NumMat<Complex>& xLocal )
@@ -735,7 +735,7 @@ void ComplexSuperLUData::GatherDistribut
     msg << "GatherDistributedMultiVector requires SLU_NR_loc matrix with type " << SLU_NR_loc << std::endl
       << "The matrix is of type " << ptrData->A.Stype << std::endl;
     ErrorHandling( msg.str().c_str() );
-  }	
+  }
 
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
 
@@ -760,7 +760,7 @@ void ComplexSuperLUData::GatherDistribut
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::GatherDistributedMultiVector  ----- 
+} 		// -----  end of method ComplexSuperLUData::GatherDistributedMultiVector  -----
 
 
 void
@@ -776,11 +776,11 @@ ComplexSuperLUData::SolveDistMultiVector
   // TODO Complex arithmetic
 
   PStatInit(&ptrData->stat);
-  pzgssvx(&ptrData->options, &ptrData->A, &ptrData->ScalePermstruct, 
+  pzgssvx(&ptrData->options, &ptrData->A, &ptrData->ScalePermstruct,
       (doublecomplex*)bLocal.Data(), numRowLocal, nrhs, ptrData->grid,
-      &ptrData->LUstruct, &ptrData->SOLVEstruct, berr.Data(), 
+      &ptrData->LUstruct, &ptrData->SOLVEstruct, berr.Data(),
       &ptrData->stat, &ptrData->info);
-  PStatFree(&ptrData->stat); 
+  PStatFree(&ptrData->stat);
 
   if ( ptrData->options.SolveInitialized ) {
     zSolveFinalize(&ptrData->options, &ptrData->SOLVEstruct);
@@ -797,7 +797,7 @@ ComplexSuperLUData::SolveDistMultiVector
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::SolveDistMultiVector  ----- 
+} 		// -----  end of method ComplexSuperLUData::SolveDistMultiVector  -----
 
 
 void
@@ -807,13 +807,13 @@ ComplexSuperLUData::CheckErrorDistMultiV
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
   Int numRowLocal = Astore->m_loc;
 
-  pzinf_norm_error(ptrData->grid->iam, numRowLocal, nrhs, 
-      (doublecomplex*)xLocal.Data(), numRowLocal, 
+  pzinf_norm_error(ptrData->grid->iam, numRowLocal, nrhs,
+      (doublecomplex*)xLocal.Data(), numRowLocal,
       (doublecomplex*)xTrueLocal.Data(), numRowLocal, ptrData->grid);
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::CheckErrorDistMultiVector  ----- 
+} 		// -----  end of method ComplexSuperLUData::CheckErrorDistMultiVector  -----
 
 
 void
@@ -838,7 +838,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
 
 
 
-  // L part   
+  // L part
 #if ( _DEBUGlevel_ >= 1 )
   statusOFS << std::endl << "LUstructToPMatrix::L part" << std::endl;
 #endif
@@ -891,7 +891,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
         LB.blockIdx    = blockIdx;
 
         PMloc.ColBlockIdx(jb).push_back(LB.blockIdx);
-        Int LBi = LB.blockIdx / grid->numProcRow; 
+        Int LBi = LB.blockIdx / grid->numProcRow;
         PMloc.RowBlockIdx( LBi ).push_back( bnum );
 
 
@@ -906,14 +906,14 @@ ComplexSuperLUData::LUstructToPMatrix	(
         //sort the row indices (so as to speedup the index lookup
         std::sort(rowsPerm.Data(),rowsPerm.Data()+rowsPerm.m(),cmp);
 
-        for(Int i = 0; i<LB.rows.m(); ++i){ 
+        for(Int i = 0; i<LB.rows.m(); ++i){
           rowsSorted[i] = LB.rows[rowsPerm[i]];
         }
 
         LB.rows = rowsSorted;
 
-        LB.nzval.Resize( LB.numRow, LB.numCol );   
-        SetValue( LB.nzval, ZERO<Complex>() ); 
+        LB.nzval.Resize( LB.numRow, LB.numCol );
+        SetValue( LB.nzval, ZERO<Complex>() );
         cnt += LB.numRow;
 
         //sort the nzval
@@ -927,12 +927,12 @@ ComplexSuperLUData::LUstructToPMatrix	(
 
 
 #if ( _DEBUGlevel_ >= 1 )
-        statusOFS 
+        statusOFS
           << "L part: bnum = " << bnum << ", numBlock = " << Lcol.size()
           << ", blockIdx = " << LB.blockIdx
-          << ", numRow = " << LB.numRow 
+          << ", numRow = " << LB.numRow
           << ", numCol = " << LB.numCol << std::endl;
-#endif 
+#endif
 
       } // for(iblk)
 
@@ -966,11 +966,11 @@ ComplexSuperLUData::LUstructToPMatrix	(
     Int cnt = 0;                                // Count for the index in LUstruct
     Int cntval = 0;                             // Count for the nonzero values
     Int cntidx = 0;                             // Count for the nonzero block indexes
-    const Int*    index = Llu->Ufstnz_br_ptr[ib]; 
+    const Int*    index = Llu->Ufstnz_br_ptr[ib];
     const Complex* pval  = reinterpret_cast<const Complex*>(Llu->Unzval_br_ptr[ib]);
-    if( index ){ 
+    if( index ){
       // Not an empty row
-      // Compute the number of nonzero columns 
+      // Compute the number of nonzero columns
 
       std::vector<UBlock<Complex> >& Urow = PMloc.U(ib);
       Urow.resize( index[cnt++] );
@@ -982,7 +982,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
         cols.clear();
 
         Int blockIdx = index[cnt];
-        Int LBj = blockIdx / grid->numProcCol; 
+        Int LBj = blockIdx / grid->numProcCol;
         UBlock<Complex> & UB = Urow[jblk];
         UB.blockIdx = blockIdx;
 
@@ -994,7 +994,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
 
         UB.numRow = super->superPtr[bnum+1] - super->superPtr[bnum];
         cnt += UB_DESCRIPTOR;
-        //            for( Int j = FirstBlockCol( UB.blockIdx, super ); 
+        //            for( Int j = FirstBlockCol( UB.blockIdx, super );
         //                j < FirstBlockCol( UB.blockIdx+1, super ); j++ ){
         //              Int firstRow = index[cnt++];
         //              if( firstRow != FirstBlockCol( bnum+1, super ) )
@@ -1004,7 +1004,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
         //            cnt -= super->superPtr[UB.blockIdx+1] - super->superPtr[UB.blockIdx];
 
         int pos = 0;
-        for( Int j = FirstBlockCol( UB.blockIdx, super ); 
+        for( Int j = FirstBlockCol( UB.blockIdx, super );
             j < FirstBlockCol( UB.blockIdx+1, super ); j++ ){
           Int firstRow = index[cnt++];
           if( firstRow != FirstBlockCol( bnum+1, super ) )
@@ -1017,7 +1017,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
 
 
         pos = 0;
-        for( Int j = FirstBlockCol( UB.blockIdx, super ); 
+        for( Int j = FirstBlockCol( UB.blockIdx, super );
             j < FirstBlockCol( UB.blockIdx+1, super ); j++ ){
           Int firstRow = index[cnt++];
           if( firstRow != FirstBlockCol( bnum+1, super ) )
@@ -1035,7 +1035,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
         SetValue( UB.nzval, ZERO<Complex>() );
 
         Int cntcol = 0;
-        for( Int j = 0; 
+        for( Int j = 0;
             j < super->superPtr[UB.blockIdx+1] - super->superPtr[UB.blockIdx]; j++ ){
           Int firstRow = index[cnt++];
           if( firstRow != FirstBlockCol( bnum+1, super ) ){
@@ -1049,12 +1049,12 @@ ComplexSuperLUData::LUstructToPMatrix	(
         } // for( j )
 
 #if ( _DEBUGlevel_ >= 1 )
-        statusOFS 
+        statusOFS
           << "U part: bnum = " << bnum << ", numBlock = " << Urow.size()
           << ", blockIdx = " << UB.blockIdx
-          << ", numRow = " << UB.numRow 
+          << ", numRow = " << UB.numRow
           << ", numCol = " << UB.numCol << std::endl;
-#endif 
+#endif
 
       } // for (jblk)
 
@@ -1093,7 +1093,7 @@ ComplexSuperLUData::LUstructToPMatrix	(
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::LUstructToPMatrix  ----- 
+} 		// -----  end of method ComplexSuperLUData::LUstructToPMatrix  -----
 
 
 
@@ -1147,6 +1147,6 @@ ComplexSuperLUData::SymbolicToSuperNode
 
 
   return ;
-} 		// -----  end of method ComplexSuperLUData::SymbolicToSuperNode  ----- 
+} 		// -----  end of method ComplexSuperLUData::SymbolicToSuperNode  -----
 
 }
--- src/superlu_dist_internal_real.cpp.orig	2020-02-25 16:13:37.903818896 +0000
+++ src/superlu_dist_internal_real.cpp	2020-02-25 16:13:52.683927593 +0000
@@ -1,6 +1,6 @@
 /*
    Copyright (c) 2012 The Regents of the University of California,
-   through Lawrence Berkeley National Laboratory.  
+   through Lawrence Berkeley National Laboratory.
 
 Author: Lin Lin and Mathias Jacquelin
 
@@ -51,22 +51,22 @@ such enhancements or derivative works th
 #include <superlu_ddefs.h>
 #include <numeric>
 
-#include <Cnames.h>
+#include <superlu_FCnames.h>
 extern "C"{ void
 #ifdef SUPERLU_DIST_MAJOR_VERSION
 #if SUPERLU_DIST_MAJOR_VERSION < 5
-pdsymbfact(superlu_options_t *options, SuperMatrix *A, 
+pdsymbfact(superlu_options_t *options, SuperMatrix *A,
     ScalePermstruct_t *ScalePermstruct, gridinfo_t *grid,
     LUstruct_t *LUstruct, SuperLUStat_t *stat, int *numProcSymbFact,
     int *info, double *totalMemory, double *maxMemory );
 #else
-pdsymbfact(superlu_dist_options_t *options, SuperMatrix *A, 
+pdsymbfact(superlu_dist_options_t *options, SuperMatrix *A,
     ScalePermstruct_t *ScalePermstruct, gridinfo_t *grid,
     LUstruct_t *LUstruct, SuperLUStat_t *stat, int *numProcSymbFact,
     int *info, double *totalMemory, double *maxMemory );
 #endif
 #else
-pdsymbfact(superlu_dist_options_t *options, SuperMatrix *A, 
+pdsymbfact(superlu_dist_options_t *options, SuperMatrix *A,
     ScalePermstruct_t *ScalePermstruct, gridinfo_t *grid,
     LUstruct_t *LUstruct, SuperLUStat_t *stat, int *numProcSymbFact,
     int *info, double *totalMemory, double *maxMemory );
@@ -126,33 +126,33 @@ namespace PEXSI{
 class RealSuperLUData_internal{
   friend class RealSuperLUData;
 protected:
-  /// @brief SuperLU matrix. 
-  SuperMatrix         A;                        
+  /// @brief SuperLU matrix.
+  SuperMatrix         A;
 
-  /// @brief SuperLU options. 
+  /// @brief SuperLU options.
   ///
   /// Note
   /// ----
   ///
-  /// It is important to have 
+  /// It is important to have
   ///
   /// options.RowPerm           = NOROWPERM;
-  /// 
+  ///
   /// to make sure that symmetric permutation is used.
   ///
 #ifdef SUPERLU_DIST_MAJOR_VERSION
 #if SUPERLU_DIST_MAJOR_VERSION < 5
-  superlu_options_t   options;                  
+  superlu_options_t   options;
 #else
-  superlu_dist_options_t   options;                  
+  superlu_dist_options_t   options;
 #endif
 #else
-  superlu_dist_options_t   options;                  
+  superlu_dist_options_t   options;
 #endif
 
   /// @brief Saves the permutation vectors.  Only perm_c (permutation of
   /// column as well as rows due to the symmetric permutation) will be used.
-  ScalePermstruct_t   ScalePermstruct;          
+  ScalePermstruct_t   ScalePermstruct;
 
   /// @brief SuperLU grid structure.
   gridinfo_t*         grid;
@@ -205,7 +205,7 @@ RealSuperLUData_internal::RealSuperLUDat
   options.Fact              = DOFACT;
   if(opt.RowPerm == "LargeDiag"){
 #ifdef SUPERLU_DIST_MAJOR_VERSION
-#  if SUPERLU_DIST_MAJOR_VERSION < 6 
+#  if SUPERLU_DIST_MAJOR_VERSION < 6
     options.RowPerm         = LargeDiag;
 #  else
     options.RowPerm         = LargeDiag_MC64;
@@ -221,10 +221,10 @@ RealSuperLUData_internal::RealSuperLUDat
   options.IterRefine        = NOREFINE;
   options.ParSymbFact       = NO;
   if(opt.Equil == "YES"){
-    options.Equil             = YES; 
+    options.Equil             = YES;
   }
   else{
-    options.Equil             = NO; 
+    options.Equil             = NO;
   }
 
   options.ReplaceTinyPivot  = YES;
@@ -241,12 +241,12 @@ RealSuperLUData_internal::RealSuperLUDat
 
   if(opt.Symmetric == 1){
     options.RowPerm         = NOROWPERM;
-    options.Equil             = NO; 
+    options.Equil             = NO;
   }
 
   if ( opt.ColPerm == "NATURAL" ){
     options.ColPerm = NATURAL;
-  } 
+  }
   else if( opt.ColPerm == "MMD_AT_PLUS_A" ){
     options.ColPerm = MMD_AT_PLUS_A;
   }
@@ -271,7 +271,7 @@ RealSuperLUData_internal::RealSuperLUDat
 RealSuperLUData_internal::~RealSuperLUData_internal(){
   if( isLUstructAllocated ){
     Destroy_LU(A.ncol, grid, &LUstruct);
-    LUstructFree(&LUstruct); 
+    LUstructFree(&LUstruct);
   }
   if( isScalePermstructAllocated ){
     ScalePermstructFree(&ScalePermstruct);
@@ -323,7 +323,7 @@ RealSuperLUData_internal::DestroyAOnly	(
   isSuperMatrixAllocated = false;
 
   return ;
-} 		// -----  end of method RealSuperLUData_internal::DestroyAOnly  ----- 
+} 		// -----  end of method RealSuperLUData_internal::DestroyAOnly  -----
 
 
 RealSuperLUData::RealSuperLUData( const SuperLUGrid<Real>& g, const SuperLUOptions& opt ){
@@ -381,16 +381,16 @@ RealSuperLUData & RealSuperLUData::opera
 
 
 
-Int RealSuperLUData::m (  ) const	
+Int RealSuperLUData::m (  ) const
 {
   return ptrData->A.nrow;
-} 		// -----  end of method RealSuperLUData::m  ----- 
+} 		// -----  end of method RealSuperLUData::m  -----
 
 
-Int RealSuperLUData::n (  ) const	
+Int RealSuperLUData::n (  ) const
 {
   return ptrData->A.ncol;
-} 		// -----  end of method RealSuperLUData::n  ----- 
+} 		// -----  end of method RealSuperLUData::n  -----
 
 void RealSuperLUData::DistSparseMatrixToSuperMatrixNRloc( DistSparseMatrix<Real>& sparseA , const SuperLUOptions & options)
 {
@@ -413,7 +413,7 @@ void RealSuperLUData::DistSparseMatrixTo
     numRowLocal = sparseA.colptrLocal.m() - 1;
     nnzLocal = sparseA.nnzLocal;
 
-    colindLocal = (int_t*)intMalloc_dist(sparseA.nnzLocal); 
+    colindLocal = (int_t*)intMalloc_dist(sparseA.nnzLocal);
     nzvalLocal  = (double*)doubleMalloc_dist(sparseA.nnzLocal);
     rowptrLocal = (int_t*)intMalloc_dist(numRowLocal+1);
 
@@ -431,7 +431,7 @@ void RealSuperLUData::DistSparseMatrixTo
     numRowLocal = sparseB.colptrLocal.m() - 1;
     nnzLocal = sparseB.nnzLocal;
 
-    colindLocal = (int_t*)intMalloc_dist(sparseB.nnzLocal); 
+    colindLocal = (int_t*)intMalloc_dist(sparseB.nnzLocal);
     nzvalLocal  = (double*)doubleMalloc_dist(sparseB.nnzLocal);
     rowptrLocal = (int_t*)intMalloc_dist(numRowLocal+1);
 
@@ -454,7 +454,7 @@ void RealSuperLUData::DistSparseMatrixTo
   }
 
   // Construct the distributed matrix according to the SuperLU_DIST format
-  dCreate_CompRowLoc_Matrix_dist(&ptrData->A, sparseA.size, sparseA.size, sparseA.nnzLocal, 
+  dCreate_CompRowLoc_Matrix_dist(&ptrData->A, sparseA.size, sparseA.size, sparseA.nnzLocal,
       numRowLocal, firstRow,
       nzvalLocal, colindLocal, rowptrLocal,
       SLU_NR_loc, SLU_D, SLU_GE);
@@ -464,14 +464,14 @@ void RealSuperLUData::DistSparseMatrixTo
 
   return;
 
-} 		// -----  end of method RealSuperLUData::DistSparseMatrixToSuperMatrixNRloc ----- 
+} 		// -----  end of method RealSuperLUData::DistSparseMatrixToSuperMatrixNRloc -----
 
 void
 RealSuperLUData::DestroyAOnly	(  )
 {
   ptrData->DestroyAOnly();
   return ;
-} 		// -----  end of method RealSuperLUData::DestroyAOnly  ----- 
+} 		// -----  end of method RealSuperLUData::DestroyAOnly  -----
 
 void
 RealSuperLUData::SymbolicFactorize	(  )
@@ -500,7 +500,7 @@ RealSuperLUData::SymbolicFactorize	(  )
 
   double totalMemory = 0.0, maxMemory = 0.0;
 
-  pdsymbfact(&ptrData->options, &A, &ptrData->ScalePermstruct, ptrData->grid, 
+  pdsymbfact(&ptrData->options, &A, &ptrData->ScalePermstruct, ptrData->grid,
       &ptrData->LUstruct, &ptrData->stat, &ptrData->numProcSymbFact, &ptrData->info,
       &totalMemory, &maxMemory);
   PStatFree(&ptrData->stat);
@@ -511,7 +511,7 @@ RealSuperLUData::SymbolicFactorize	(  )
 
 #if ( _DEBUGlevel_ >= 0 )
   statusOFS << "Memory cost of symbolic factorization (MB): " << std::endl;
-  statusOFS << "Total: " << totalMemory << ", Average: " << 
+  statusOFS << "Total: " << totalMemory << ", Average: " <<
     totalMemory / ( ptrData->grid->nprow * ptrData->grid->npcol )
     << ", Max: " << maxMemory << std::endl << std::endl;
 #endif
@@ -519,24 +519,24 @@ RealSuperLUData::SymbolicFactorize	(  )
 
 
   ptrData->isScalePermstructAllocated = true;
-  ptrData->isLUstructAllocated        = true; 
+  ptrData->isLUstructAllocated        = true;
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::SymbolicFactorize  ----- 
+} 		// -----  end of method RealSuperLUData::SymbolicFactorize  -----
 
 void
 RealSuperLUData::Distribute	(  )
 {
   if( ptrData->isScalePermstructAllocated == false ){
     ErrorHandling( "ScalePermstruct has not been allocated by SymbolicFactorize." );
-  }	
+  }
   if( ptrData->isLUstructAllocated == false ){
     ErrorHandling( "LUstruct has not been allocated by SymbolicFactorize." );
-  }	
+  }
   if( ptrData->isSuperMatrixAllocated == false ){
     ErrorHandling( "SuperMatrix has not been allocated." );
-  }	
+  }
 
   Int* perm_c = ptrData->ScalePermstruct.perm_c;
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
@@ -545,15 +545,15 @@ RealSuperLUData::Distribute	(  )
   // Apply column permutation to the original distributed A
   for(Int j = 0; j < nnzLocal; j++)
     colind[j] = perm_c[colind[j]];
-  // Distribute Pc*Pr*diag(R)*A*diag(C)*Pc' into L and U storage.  
+  // Distribute Pc*Pr*diag(R)*A*diag(C)*Pc' into L and U storage.
   // NOTE: the row permutation Pc*Pr is applied internally in the
-  // distribution routine. 
-  float dist_mem_use = pddistribute(SamePattern_SameRowPerm, ptrData->A.nrow, 
+  // distribution routine.
+  float dist_mem_use = pddistribute(SamePattern_SameRowPerm, ptrData->A.nrow,
       &ptrData->A, &ptrData->ScalePermstruct, NULL, &ptrData->LUstruct, ptrData->grid);
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::Distribute  ----- 
+} 		// -----  end of method RealSuperLUData::Distribute  -----
 
 void
 RealSuperLUData::NumericalFactorize	(  )
@@ -566,21 +566,21 @@ RealSuperLUData::NumericalFactorize	(  )
   double anorm = pdlangs( norm, &ptrData->A, ptrData->grid );
 
   PStatInit(&ptrData->stat);
-  pdgstrf(&ptrData->options, ptrData->A.nrow, ptrData->A.ncol, 
-      anorm, &ptrData->LUstruct, ptrData->grid, &ptrData->stat, &ptrData->info); 
+  pdgstrf(&ptrData->options, ptrData->A.nrow, ptrData->A.ncol,
+      anorm, &ptrData->LUstruct, ptrData->grid, &ptrData->stat, &ptrData->info);
 
 #ifdef _PRINT_STATS_
-  statusOFS<<"******************SUPERLU STATISTICS****************"<<std::endl;  
-  statusOFS<<"Number of tiny pivots: "<<ptrData->stat.TinyPivots<<std::endl;  
-  statusOFS<<"Number of look aheads: "<<ptrData->stat.num_look_aheads<<std::endl;  
-  
+  statusOFS<<"******************SUPERLU STATISTICS****************"<<std::endl;
+  statusOFS<<"Number of tiny pivots: "<<ptrData->stat.TinyPivots<<std::endl;
+  statusOFS<<"Number of look aheads: "<<ptrData->stat.num_look_aheads<<std::endl;
+
   float flopcnt = 0;
   MPI_Allreduce(&ptrData->stat.ops[FACT], &flopcnt, 1, MPI_FLOAT, MPI_SUM, ptrData->grid->comm);
-  statusOFS<<"Number of FLOPS for factorization: "<<flopcnt<<std::endl;  
+  statusOFS<<"Number of FLOPS for factorization: "<<flopcnt<<std::endl;
   if(!ptrData->grid->iam){
     std::cout<<"Total FLOPs for factorization is "<<flopcnt<<std::endl;
   }
-  statusOFS<<"****************************************************"<<std::endl;  
+  statusOFS<<"****************************************************"<<std::endl;
 #endif
 
 
@@ -601,7 +601,7 @@ RealSuperLUData::NumericalFactorize	(  )
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::NumericalFactorize  ----- 
+} 		// -----  end of method RealSuperLUData::NumericalFactorize  -----
 
 void
 RealSuperLUData::ConvertNRlocToNC	( RealSuperLUData * aptrData )
@@ -616,14 +616,14 @@ RealSuperLUData::ConvertNRlocToNC	( Real
 
   // TODO real arithmetic
   const Int NEED_VALUE = 1;
-  pdCompRow_loc_to_CompCol_global(NEED_VALUE, &ptrData->A, ptrData->grid, 
+  pdCompRow_loc_to_CompCol_global(NEED_VALUE, &ptrData->A, ptrData->grid,
       &aptrData->ptrData->A);
 
   ptrData->isSuperMatrixAllocated = true;
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::ConvertNRlocToNC  ----- 
+} 		// -----  end of method RealSuperLUData::ConvertNRlocToNC  -----
 
 void
 RealSuperLUData::MultiplyGlobalMultiVector	( NumMat<Real>& xGlobal, NumMat<Real>& bGlobal )
@@ -639,12 +639,12 @@ RealSuperLUData::MultiplyGlobalMultiVect
       << "The matrix is of type " << ptrData->A.Stype << std::endl
       << "Consider using ConvertNRlocToNC subroutine" << std::endl;
     ErrorHandling( msg.str().c_str() );
-  }	
-  dFillRHS_dist(trans, nrhs, (double*)xGlobal.Data(), m, 
+  }
+  dFillRHS_dist(trans, nrhs, (double*)xGlobal.Data(), m,
       &ptrData->A, (double*) bGlobal.Data(), m);
 
   return ;
-} 		// -----  end of method RealSuperLUData::MultiplyGlobalMultiVector  ----- 
+} 		// -----  end of method RealSuperLUData::MultiplyGlobalMultiVector  -----
 
 
 void
@@ -656,7 +656,7 @@ RealSuperLUData::DistributeGlobalMultiVe
     msg << "DistributeGlobalMultiVector requires SLU_NR_loc matrix with type " << SLU_NR_loc << std::endl
       << "The matrix is of type " << ptrData->A.Stype << std::endl;
     ErrorHandling( msg.str().c_str() );
-  }	
+  }
 
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
 
@@ -673,7 +673,7 @@ RealSuperLUData::DistributeGlobalMultiVe
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::DistributeGlobalMultiVector  ----- 
+} 		// -----  end of method RealSuperLUData::DistributeGlobalMultiVector  -----
 
 
 void RealSuperLUData::GatherDistributedMultiVector	( NumMat<Real>& xGlobal, NumMat<Real>& xLocal )
@@ -684,7 +684,7 @@ void RealSuperLUData::GatherDistributedM
     msg << "GatherDistributedMultiVector requires SLU_NR_loc matrix with type " << SLU_NR_loc << std::endl
       << "The matrix is of type " << ptrData->A.Stype << std::endl;
     ErrorHandling( msg.str().c_str() );
-  }	
+  }
 
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
 
@@ -709,7 +709,7 @@ void RealSuperLUData::GatherDistributedM
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::GatherDistributedMultiVector  ----- 
+} 		// -----  end of method RealSuperLUData::GatherDistributedMultiVector  -----
 
 
 void
@@ -725,11 +725,11 @@ RealSuperLUData::SolveDistMultiVector	(
   // TODO Real arithmetic
 
   PStatInit(&ptrData->stat);
-  pdgssvx(&ptrData->options, &ptrData->A, &ptrData->ScalePermstruct, 
+  pdgssvx(&ptrData->options, &ptrData->A, &ptrData->ScalePermstruct,
       (double*)bLocal.Data(), numRowLocal, nrhs, ptrData->grid,
-      &ptrData->LUstruct, &ptrData->SOLVEstruct, berr.Data(), 
+      &ptrData->LUstruct, &ptrData->SOLVEstruct, berr.Data(),
       &ptrData->stat, &ptrData->info);
-  PStatFree(&ptrData->stat); 
+  PStatFree(&ptrData->stat);
 
   if ( ptrData->options.SolveInitialized ) {
     dSolveFinalize(&ptrData->options, &ptrData->SOLVEstruct);
@@ -746,7 +746,7 @@ RealSuperLUData::SolveDistMultiVector	(
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::SolveDistMultiVector  ----- 
+} 		// -----  end of method RealSuperLUData::SolveDistMultiVector  -----
 
 
 void
@@ -756,13 +756,13 @@ RealSuperLUData::CheckErrorDistMultiVect
   NRformat_loc *Astore = (NRformat_loc *) ptrData->A.Store;
   Int numRowLocal = Astore->m_loc;
 
-  pdinf_norm_error(ptrData->grid->iam, numRowLocal, nrhs, 
-      (double*)xLocal.Data(), numRowLocal, 
+  pdinf_norm_error(ptrData->grid->iam, numRowLocal, nrhs,
+      (double*)xLocal.Data(), numRowLocal,
       (double*)xTrueLocal.Data(), numRowLocal, ptrData->grid);
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::CheckErrorDistMultiVector  ----- 
+} 		// -----  end of method RealSuperLUData::CheckErrorDistMultiVector  -----
 
 
 void
@@ -773,7 +773,7 @@ RealSuperLUData::LUstructToPMatrix	( PMa
   const SuperNodeType* super = PMloc.SuperNode();
   Int numSuper = PMloc.NumSuper();
 
-  // L part   
+  // L part
 #if ( _DEBUGlevel_ >= 1 )
   statusOFS << std::endl << "LUstructToPMatrix::L part" << std::endl;
 #endif
@@ -791,7 +791,7 @@ RealSuperLUData::LUstructToPMatrix	( PMa
     Int cntval = 0;                             // Count for the nonzero values
     Int cntidx = 0;                             // Count for the nonzero block indexes
     const Int* index = Llu->Lrowind_bc_ptr[jb];
-    if( index ){ 
+    if( index ){
       // Not an empty column, start a new column then.
       std::vector<LBlock<Real> >& Lcol = PMloc.L(jb);
       Lcol.resize( index[cnt++] );
@@ -831,7 +831,7 @@ RealSuperLUData::LUstructToPMatrix	( PMa
         LB.blockIdx    = blockIdx;
 
         PMloc.ColBlockIdx(jb).push_back(LB.blockIdx);
-        Int LBi = LB.blockIdx / grid->numProcRow; 
+        Int LBi = LB.blockIdx / grid->numProcRow;
         PMloc.RowBlockIdx( LBi ).push_back( bnum );
 
 
@@ -846,14 +846,14 @@ RealSuperLUData::LUstructToPMatrix	( PMa
         //sort the row indices (so as to speedup the index lookup
         std::sort(rowsPerm.Data(),rowsPerm.Data()+rowsPerm.m(),cmp);
 
-        for(Int i = 0; i<LB.rows.m(); ++i){ 
+        for(Int i = 0; i<LB.rows.m(); ++i){
           rowsSorted[i] = LB.rows[rowsPerm[i]];
         }
 
         LB.rows = rowsSorted;
 
-        LB.nzval.Resize( LB.numRow, LB.numCol );   
-        SetValue( LB.nzval, ZERO<Real>() ); 
+        LB.nzval.Resize( LB.numRow, LB.numCol );
+        SetValue( LB.nzval, ZERO<Real>() );
         cnt += LB.numRow;
 
         //sort the nzval
@@ -867,12 +867,12 @@ RealSuperLUData::LUstructToPMatrix	( PMa
 
 
 #if ( _DEBUGlevel_ >= 1 )
-        statusOFS 
+        statusOFS
           << "L part: bnum = " << bnum << ", numBlock = " << Lcol.size()
           << ", blockIdx = " << LB.blockIdx
-          << ", numRow = " << LB.numRow 
+          << ", numRow = " << LB.numRow
           << ", numCol = " << LB.numCol << std::endl;
-#endif 
+#endif
 
       } // for(iblk)
 
@@ -899,11 +899,11 @@ RealSuperLUData::LUstructToPMatrix	( PMa
     Int cnt = 0;                                // Count for the index in LUstruct
     Int cntval = 0;                             // Count for the nonzero values
     Int cntidx = 0;                             // Count for the nonzero block indexes
-    const Int*    index = Llu->Ufstnz_br_ptr[ib]; 
+    const Int*    index = Llu->Ufstnz_br_ptr[ib];
     const Real* pval  = reinterpret_cast<const Real*>(Llu->Unzval_br_ptr[ib]);
-    if( index ){ 
+    if( index ){
       // Not an empty row
-      // Compute the number of nonzero columns 
+      // Compute the number of nonzero columns
       std::vector<UBlock<Real> >& Urow = PMloc.U(ib);
       Urow.resize( index[cnt++] );
       cnt = BR_HEADER;
@@ -918,13 +918,13 @@ RealSuperLUData::LUstructToPMatrix	( PMa
 
 
         PMloc.RowBlockIdx(ib).push_back(UB.blockIdx);
-        Int LBj = UB.blockIdx / grid->numProcCol; 
+        Int LBj = UB.blockIdx / grid->numProcCol;
         PMloc.ColBlockIdx( LBj ).push_back( bnum );
 
 
         UB.numRow = super->superPtr[bnum+1] - super->superPtr[bnum];
         cnt += UB_DESCRIPTOR;
-        for( Int j = FirstBlockCol( UB.blockIdx, super ); 
+        for( Int j = FirstBlockCol( UB.blockIdx, super );
             j < FirstBlockCol( UB.blockIdx+1, super ); j++ ){
           Int firstRow = index[cnt++];
           if( firstRow != FirstBlockCol( bnum+1, super ) )
@@ -939,7 +939,7 @@ RealSuperLUData::LUstructToPMatrix	( PMa
         SetValue( UB.nzval, ZERO<Real>() );
 
         Int cntcol = 0;
-        for( Int j = 0; 
+        for( Int j = 0;
             j < super->superPtr[UB.blockIdx+1] - super->superPtr[UB.blockIdx]; j++ ){
           Int firstRow = index[cnt++];
           if( firstRow != FirstBlockCol( bnum+1, super ) ){
@@ -953,12 +953,12 @@ RealSuperLUData::LUstructToPMatrix	( PMa
         } // for( j )
 
 #if ( _DEBUGlevel_ >= 1 )
-        statusOFS 
+        statusOFS
           << "U part: bnum = " << bnum << ", numBlock = " << Urow.size()
           << ", blockIdx = " << UB.blockIdx
-          << ", numRow = " << UB.numRow 
+          << ", numRow = " << UB.numRow
           << ", numCol = " << UB.numCol << std::endl;
-#endif 
+#endif
 
       } // for (jblk)
 
@@ -982,7 +982,7 @@ RealSuperLUData::LUstructToPMatrix	( PMa
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::LUstructToPMatrix  ----- 
+} 		// -----  end of method RealSuperLUData::LUstructToPMatrix  -----
 
 
 
@@ -1036,7 +1036,7 @@ RealSuperLUData::SymbolicToSuperNode	( S
 
 
   return ;
-} 		// -----  end of method RealSuperLUData::SymbolicToSuperNode  ----- 
+} 		// -----  end of method RealSuperLUData::SymbolicToSuperNode  -----
 
 
 }
